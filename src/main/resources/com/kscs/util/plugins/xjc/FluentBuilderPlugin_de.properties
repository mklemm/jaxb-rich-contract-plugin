usage=Generiert einen "fluent builder" f\u00FCr JAXB-Klassen.
usage.generateTools=Generiere Hilfsklassen als Quelltext. Wenn dies ausgeschaltet ist, muss sich das Plugin-JAR zur Laufzeit im Klassenpfad \
  der generierten Klassendefinitionen befinden.
usage.narrow=F\u00FCr untergeordnete Knoten im zu kopierenden Objektbaum werden ebenfalls die Copy-Konstruktoren der deklarierten Typen verwendet, \
  soweit diese vorhanden sind und die Typen der entsprechenden Instanzen ebenfalls aus dem XSD-Model generierte Klassen sind. Dies erzeugt eine m\u00F6glichst \
  "schmale" Kopie des Ausgangsobjekts, was in bestimmten F\u00E4llen n\u00FCtzlich sein kann.\nEin Unterknoten, dessen Typ nicht im aktuellen XSD-Modell deklariert ist, \
  wird immer wie bei der 'clone()'-Methode kopiert. Ist diese Option "no", gilt dies auch f\u00FCr generierte Typen.
usage.copyPartial=Generiert zus\u00E4tzlich eine 'copyOf()'-Methode \
  mit der sich Objekte partiell kopieren lassen. Dabei wird ein PropertyTree-Objekt mitgegeben, welches die zu kopierenden Knoten des Objektbaumes angibt.
usage.selectorClassName=Name der generierten inneren "Selector" Builder-Klasse, die intern zum Aufbau des Property-Baums f\u00FCr das partielle Kopieren benutzt wird. \
  Diese Einstellung wird nur dann ber\u00FCcksichtigt, wenn das "Deep Copy"-Plugin nicht aktiv ist, und "copy-partial=y" ist. Ansonsten gilt die Einstellung des "Deep Copy"-Plugins.
usage.rootSelectorClassName=Name der generierten inneren "Select" -Klasse, die vom aufrufenden Code als Einstieg in den Aufbau eines Property-Baumes f\u00FCr das partielle Kopieren verwendet werden kann. \
  Diese Einstellung wird nur dann ber\u00FCcksichtigt, wenn das "Deep Copy"-Plugin nicht aktiv ist, und "copy-partial=y" ist. Ansonsten gilt die Einstellung des "Deep Copy"-Plugins.
usage.fluentClassName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.builderClassName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.wrapperClassName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.modifierClassName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.fluentInterfaceName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.builderInterfaceName=Name des generierten inneren Builder-Interfaces. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.wrapperInterfaceName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.modifierInterfaceName=Name der generierten inneren Builder-Klasse. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.newBuilderMethodName=Name der generierten statischen Methode zum Erzeugen eines neuen Builders. Kann hier gesetzt werden, um Namenskonflikte zu l\u00F6sen.
usage.newCopyBuilderMethodName=Name der generierten Instanzmethode zum Erzeugen eines neuen Builders, der mit dem von dieser Instanz kopierten Zustand initialisiert ist.
usage.builderFieldSuffix=Suffix, das an den Namen der generierten Sub-Builder Instanzvariablen angef\u00FCgt wird.
error.builderClassExists=Class "{0}" already contains inner class "Builder". Skipping generation of fluent builder.

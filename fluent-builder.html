<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0-M16 from src/site/markdown/fluent-builder.md at 2024-04-30
 | Rendered using Apache Maven Fluido Skin 2.0.0-M8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 2.0.0-M16" />
    <title>jaxb-rich-contract-plugin â€“ fluent-builder</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-2.0.0-M8.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-2.0.0-M8.min.js"></script>
  </head>
  <body>
    <div class="container-fluid container-fluid-top">
      <header>
        <div id="banner">
          <div class="pull-left"></div>
          <div class="pull-right"></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2024-04-30<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 4.2.0-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Getting Started</li>
    <li><a href="index.html">Overview</a></li>
    <li><a href="getting.html">Download</a></li>
    <li><a href="history.html">Version History</a></li>
    <li><a href="usage.html">Usage</a></li>
   <li class="nav-header">XJC Plugin Options</li>
    <li class="active"><a>fluent-builder</a></li>
    <li><a href="group-contract.html">group-contract</a></li>
    <li><a href="immutable.html">immutable</a></li>
    <li><a href="modifier.html">modifier</a></li>
    <li><a href="clone.html">clone</a></li>
    <li><a href="copy.html">copy</a></li>
    <li><a href="constrained-properties.html">constrained-properties</a></li>
    <li><a href="meta.html">meta</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html"><span class="icon-chevron-right"></span>Project Information</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="https://maven.apache.org/" class="builtBy" target="_blank"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn" class="span10">
<section><section>
<h2>fluent-builder</h2><section>
<h3>Motivation</h3>
<p>There already is the widely used &#x201c;fluent-api&#x201d; plugin for XJC. That, however isn't a real builder pattern since there is no distinction between initialization and state change in fluent-api.</p>
<p>fluent-builder now creates a real &#x201c;Builder&#x201d; pattern, implemented as an inner class to the generated classes.</p></section><section>
<h3>Function</h3>
<p>fluent-builder creates a builder class with a &#x201c;<a href="https://en.wikipedia.org/wiki/Fluent_interface" class="externalLink">fluent interface</a>&#x201d;, and a number of methods to create builder instances.
The builder class is generated as a static inner class to all of the value object classes generated with XJC.
It supports the &#x201c;episode&#x201d; mechanism to generate builder code seamlessly across multiple compilation schema modules.</p>
<p>Example use in code:</p>

<div class="verbatim">
<pre><code>    MyElement newElement = MyElement.builder().withPropertyA(...).withPropertyB(...).addCollectionPropertyA(...).build();
</code></pre></div><section>
<h4>Additional Features</h4><section>
<h5>&#x201c;Choice Expansion&#x201d;</h5>
<p>In standard JAXB, if you define a <code>&lt;choice&gt;</code> group in an XSD complexType definition with cardinality &#x201c;many&#x201d;, the generated code will only contain a generic collection of &#x201c;java.lang.Object&#x201d; type, named something like &#x201c;AorBorC&#x2026;&#x201d;.</p>
<p>However, fluent-builder will determine exactly which types are actually possible in this collection, and will generate individual &#x201c;addXXX&#x201d; methods for each of them.</p>
<p>So, imagine you have generated code from the XHTML 1.0 schema, and you wish to use fluent-builder to generate an XHTML document programmatically.
Now, again imagine you have already created the &#x201c;html&#x201d; and &#x201c;head&#x201d; elements, and you are about to populate the &#x201c;body&#x201d; eith a table.</p>
<p>Without fluent-builder, you would do something like:</p>

<div class="verbatim">
<pre><code class="language-java">Body body = new Body();
Table table = new Table();
body.getPorH2orH2().add(table);
Tr tr = new Tr();
table.getTheadOrTrOrTdata().add(tr);
Td td = new Td();
tr.getTd().add(td);
td.setContent(&quot;Hello World&quot;);
</code></pre></div>
<p>With fluent-builder, you can achieve the same more intuitively:</p>

<div class="verbatim">
<pre><code class="language-java">Body.builder().addTable().addTr().addTd().withContent(&quot;Hello World&quot;).end().end().end().build();
</code></pre></div></section><section>
<h5>Object Deep-Copy strategies and Behaviors</h5>
<p>In addition, new instances can be created as copies of existing instances using the builder, with an optional modification by other builder methods:</p>Static Deep Copy

<div class="verbatim">
<pre><code>    MyElement newElement = MyElement.copyOf(oldElement).withPropertyA(...).withPropertyB(...).build();
</code></pre></div>
<p>Or, similar to the java <code>clone()</code> method, creating a runtime copy of a reference:</p>Polymorphic Deep Copy

<div class="verbatim">
<pre><code>	MyObj myObj = oldObj.newCopyBuilder().with... .build();
</code></pre></div>Partial Copy (Static and Polymorphic)
<p>The &#x201c;partial&#x201d; copy introduced in the &#x201c;copy&#x201d; plugin will work here as well, with both static (<code>copyOf()</code>) as well as polymorphic (<code>newCopyBuilder()</code>) behaviors:</p>

<div class="verbatim">
<pre><code>    PropertyTree selection = MyElement.Select.root().propertyA().propertyAB().build();
    MyElement newElement = MyElement.copyExcept(oldElement, selection).withPropertyA(...).withPropertyB(...).build();
	MyObj myObj = oldObj.newCopyBuilder(selection, PropertyTreeUse.EXCLUDE).with.... .build();
</code></pre></div>Static vs. Polymorphic Deep Copy
<p>The difference between <code>copyOf()</code> and <code>newCopyBuilder()</code> is their respective polymorphic behavior.
<code>newCopyBuilder()</code> always returns a builder instance that corresponds to the current runtime type of the object upon which the <code>newCopyBuilder()</code> method was invoked.
I.e., using <code>newCopyBuilder()</code>, you always get an object of exactly the same type as before as soon as you call <code>build()</code>.</p>
<p>In contrast, <code>MyClass.copyOf()</code>, being a static method, always returns an object of the class on which it is called, <code>MyClass</code> in this case.
You can pass an object of any base type (from the same XSD model or one referenced via &#x201c;episode&#x201d;) or any derived type of <code>MyClass</code> to <code>copyOf()</code>, and you still get an instance of <code>MyClass</code> as
soon as you call <code>build()</code>.
If you pass an instance of a more general class than <code>MyClass</code> to <code>MyClass.copyOf()</code>, the generated code will only copy the fields that exist in the argument object, and will leave all additional fields uninitialized.
You should then initialize them with the other builder methods.</p></section><section>
<h5>Chained Builder Support</h5>
<p>Often, properties of generated classes represent containment or references to generated classes in the same model.
The fluent-builder plugin lets you initialise properties of such a type (and of types declared in upstream modules
via the &#x201c;episode&#x201d; feature) - if it isn't an abstract type - by using sub-builders (&#x201c;chained&#x201d; builders) in the following
way, given that both A and B are types defined in the XSD model, and A has a property of type B, and B has three
properties of type String, x,y, and z:</p>

<div class="verbatim">
<pre><code>    A newA = A.builder().withB().withX(&quot;x&quot;).withY(&quot;y&quot;).withZ(&quot;z&quot;).end().build();
</code></pre></div>
<p>Of course, this plugin is most useful if <code>immutable</code> is also activated.</p></section></section><section>
<h4>Javadoc genration from schema annotations</h4>
<p>By default <em>xjc</em> will add class level Javadoc content from the <code>xs:annotation/xs:documentation</code> element of the corresponding named/anonymous complex type or root element.
If you enable <code>generateJavadocFromAnnotations</code> fluent-builder will additionally generate javadoc comments for class getters/setters and builder add/with methods.
This enables you to add rich documentation to the schema that will also be available in the JAXB generated code.
The content of the <code>&lt;xs:documentaion&gt;</code> element will be added to the head of the existing javadoc comment section as a new paragraph.</p><section>
<h5>Class level Javadoc</h5>
<p>Class level Javadoc comments are generated by <em>xjc</em> from anonymous compex types as follows:</p>

<div class="verbatim">
<pre><code class="language-xml">  &lt;element name=&quot;root-element&quot;&gt;
    &lt;complexType&gt;
      &lt;annotation&gt;
        &lt;documentation&gt;This is my Anonymous complex type annotation.&lt;/documentation&gt;
      &lt;/annotation&gt;
      &lt;sequence&gt;
        &lt;element name=&quot;child-element&quot; type=&quot;string&quot;&gt;
</code></pre></div>
<p>This will produce Javadoc similar to:</p>

<div class="verbatim">
<pre><code class="language-java">/**
 * This is my Anonymous complex type annotation.
 * 
 * &lt;p&gt;Java class for anonymous complex type.
 * ...
 */
 // ...
 public class RootElement implements Cloneable
</code></pre></div>
<p>Class level javadoc comments are also generated from named complex types as follows:</p>

<div class="verbatim">
<pre><code class="language-xml">  &lt;complexType name=&quot;some-complex-type&quot;&gt;
    &lt;annotation&gt;
      &lt;documentation&gt;This is my named complex type annotation&lt;/documentation&gt;
    &lt;/annotation&gt;
    &lt;sequence&gt;
      &lt;element name=&quot;some-element&quot; type=&quot;string&quot;&gt;
</code></pre></div>
<p>This will produce Javadoc similar to:</p>

<div class="verbatim">
<pre><code class="language-java">/**
 * This is my named complex type annotation
 * 
 * &lt;p&gt;Java class for some-complex-type complex type.
 * ...
 */
 // ...
 public class SomeComplexType implements Cloneable
</code></pre></div></section><section>
<h5>Method level Javadoc</h5>
<p>Method level Javadoc will be added to the get&#x2026;/set&#x2026; methods that corresponds to the schema <code>element</code> or <code>attribute</code> that contains the <code>annotation/documentation</code> element. It will also be added to the with&#x2026;/add&#x2026; builder methods.</p>
<p>For example, the schema annotation should be as follows:</p>

<div class="verbatim">
<pre><code class="language-xml">    &lt;sequence&gt;
      &lt;element name=&quot;some-element&quot; type=&quot;string&quot;&gt;
        &lt;annotation&gt;
          &lt;documentation&gt;This is my element annotation&lt;/documentation&gt;
        &lt;/annotation&gt;
      &lt;/element&gt;
</code></pre></div>
<p>This will produce java code in the corresponding class along the lines of:</p>

<div class="verbatim">
<pre><code class="language-java">    /**
     * This is my element annotation
     * &lt;P&gt;
     * Gets the value of the someElement property.
     * ...
     */
    public String getSomeElement() {
        return someElement;
    }

    /**
     * This is my element annotation
     * &lt;P&gt;
     * Sets the value of the someElement property.
     * ...
     */
    protected void setSomeElement(String value) {
        this.someElement = value;
    }
</code></pre></div>
<p>And java code in the corresponding Builder class as follows:</p>

<div class="verbatim">
<pre><code class="language-java">        /**
         * This is my element annotation
         * &lt;P&gt;
         * Sets the new value of &quot;someElement&quot; (any previous value will be replaced)
         * ...
         */
        public SomeComplexType.Builder&lt;_B&gt; withSomeElement(final String someElement) {
            // ...
        }
</code></pre></div></section></section></section><section>
<h3>Limitations</h3>
<ul>

<li>It generates a large amount of code.</li>
<li>Note: Shared builder instances are NOT thread-safe by themselves.</li>
</ul></section><section>
<h3>Usage</h3><section>
<h4>-Xfluent-builder</h4></section><section>
<h4>Options</h4><section>
<h5>-fluent-builder.rootSelectorClassName=<code>&lt;string&gt;</code> (Select)</h5>
<p>Name of the generated nested static &#x201c;Select&#x201d; entry point class to be used by client code for the &#x201c;partial copy&#x201d; feature. This setting will only have an effect if the &#x201c;deep-copy-plugin&#x201d; isn't also active. If it is, the &#x201c;copy&#x201d; plugin's settings will take precedence.</p></section><section>
<h5>-fluent-builder.newBuilderMethodName=<code>&lt;string&gt;</code> (builder)</h5>
<p>Name of the generated static method to instantiate a new fluent builder. Can be set to handle naming conflicts.</p></section><section>
<h5>-fluent-builder.newCopyBuilderMethodName=<code>&lt;string&gt;</code> (newCopyBuilder)</h5>
<p>Name of the generated instance method to instantiate a new fluent builder intitialized with a copy of the current instance.</p></section><section>
<h5>-fluent-builder.copyToMethodName=<code>&lt;string&gt;</code> (copyTo)</h5>
<p>Name of the generated &#x201c;copyTo&#x201d; method.</p></section><section>
<h5>-fluent-builder.builderFieldSuffix=<code>&lt;string&gt;</code> (_Builder)</h5>
<p>Suffix to append to the field holding the builder, change to  prevent name clashes.</p></section><section>
<h5>-fluent-builder.generateTools=<code>{y|n}</code> (y)</h5>
<p>Generate utility classes as static source code artifacts. If no, the plugin JAR must be in compile- and runtime classpath.</p></section><section>
<h5>-fluent-builder.narrow=<code>{y|n}</code> (n)</h5>
<p>Uses copy constructors for all child nodes in the object tree as long as they are available. This will cause the new instance to be as narrow as possible to the declared types.
Abstract types and types not generated from this XSD-model will always be copied by their &#x201c;clone()&#x201d;-method.</p></section><section>
<h5>-fluent-builder.copyPartial=<code>{y|n}</code> (y)</h5>
<p>Generates an additional &#x2018;copyOf&#x2019;-method  that takes a PropertyTree instance to restrict the copy operation to selected nodes in the object tree.</p></section><section>
<h5>-fluent-builder.selectorClassName=<code>&lt;string&gt;</code> (Selector)</h5>
<p>Name of the generated nested &#x201c;Selector&#x201d; builder class, used to build up a property tree for partial copy functionality. This setting will only have an effect if the &#x201c;deep-copy-plugin&#x201d; isn't also active. If it is, the &#x201c;copy&#x201d; plugin's settings will take precedence.</p></section><section>
<h5>-fluent-builder.builderClassName=<code>&lt;string&gt;</code> (Builder)</h5>
<p>Name of the generated nested builder class. Can be set to handle naming conflicts.</p></section><section>
<h5>-fluent-builder.builderInterfaceName=<code>&lt;string&gt;</code> (BuildSupport)</h5>
<p>Name of the generated nested builder interface. Can be set to handle naming conflicts.</p></section><section>
<h5>-fluent-builder.copyAlways=<code>{y|n}</code> (n)</h5>
<p>If true, generate code of fluent-builder &#x201c;withXXX&#x201d; methods so that all objects passed to the builder are inherently deep-copied.</p></section><section>
<h5>-fluent-builder.buildMethodName=<code>&lt;string&gt;</code> (build)</h5>
<p>Name of the generated &#x201c;build&#x201d; method that concludes building and returns the product. Can be set here to handle naming conflicts.</p></section><section>
<h5>-fluent-builder.endMethodName=<code>&lt;string&gt;</code> (end)</h5>
<p>Name of the generated &#x201c;end&#x201d; method that concludes a nested builder and returns to the outer builder. Can be set here to handle naming conflicts.</p></section><section>
<h5>-fluent-builder.generateJavadocFromAnnotations=<code>{y|n}</code> (n)</h5>
<p>If true, append schema annotation text (./annotation/documentation) to class getters/setters and builder methods.</p></section></section></section></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Â©      2024
</p>
        </div>
      </div>
    </footer>
<script>
  if(anchors) {
    anchors.add();
  }
</script>
  </body>
</html>